{"meta":{"title":"大头同学","subtitle":"Just Coding.","description":null,"author":"Calmnea","url":"https://calmnea.github.io"},"pages":[{"title":"标签","date":"2018-01-03T13:26:00.000Z","updated":"2018-01-03T13:28:18.763Z","comments":false,"path":"tags/index.html","permalink":"https://calmnea.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2018-01-03T13:28:05.558Z","comments":false,"path":"categories/index.html","permalink":"https://calmnea.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"[LeetCode刷题笔记]2. Add Two Numbers","slug":"LeetCode刷题笔记-2-Add-Two-Numbers","date":"2018-03-12T13:09:58.000Z","updated":"2018-03-12T14:01:00.364Z","comments":true,"path":"posts/29320018.html","link":"","permalink":"https://calmnea.github.io/posts/29320018.html","excerpt":"","text":"Descripition You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个非空链表，分别表示两个逆序排列的非负整数，每个节点包含一个单一数字，求得两个整数的和并返回响应的链表表示。假设给定的整数不会包含前导0，除非整数就是0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 分析同时遍历两个整数链表，使用尾插法更新结果链表，新节点值为当前两节点值与前一轮进位和的个位结果，同时更新当前轮次的进位标记。 Tips： 因两整数链表长度不一定相等，为方便操作，当遍历到某个链表节点为空时，可假定其取值为0 当遍历到两个链表节点均为空时，还需检查最后的进位标志 时间复杂度和空间复杂度均为O(max(n, m))，n和m分表代表两个链表的长度。 C++ Code：1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; // 为方便操作, 为结果链表构建头结点 ListNode* L = new ListNode(-1); ListNode* p = L; int ca = 0; // 进位标志 int v1, v2, sum, unit; while (l1 || l2) &#123; v1 = l1 ? l1-&gt;val : 0; v2 = l2 ? l2-&gt;val : 0; sum = v1 + v2 + ca; unit = sum % 10; ca = sum / 10; l1 = l1 ? l1-&gt;next : nullptr; l2 = l2 ? l2-&gt;next : nullptr; p-&gt;next = new ListNode(unit); p = p-&gt;next; &#125; if (ca &gt; 0) &#123; p-&gt;next = new ListNode(ca); &#125; return L-&gt;next; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://calmnea.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://calmnea.github.io/tags/LeetCode/"},{"name":"算法","slug":"algorithm","permalink":"https://calmnea.github.io/tags/algorithm/"}]},{"title":"[LeetCode刷题笔记]1. Two Sum","slug":"LeetCode刷题笔记-1-Two-Sum","date":"2018-03-12T12:22:31.000Z","updated":"2018-03-12T13:05:43.079Z","comments":true,"path":"posts/982674978.html","link":"","permalink":"https://calmnea.github.io/posts/982674978.html","excerpt":"","text":"Descripition Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整形数组，返回相加等于指定目标数字的元素下标，假设每组输入恰好只有一种可能的解，并且同一元素不能使用两次。 Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 分析遍历一遍数组，遍历的同时，用一个map记录经过的数字与下标，每遇到一个新的元素，查找目标值与该元素的差是否存于在map中，若存在则返回对应下标，否则继续遍历。 最坏情况需一次遍历和正比数组长度的额外空间，因此时间复杂度和空间复杂度均为O(n)。 C++ Code:123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; rev; unordered_map&lt;int, int&gt; mapping; int size = nums.size(); for (int i = 0; i &lt; size; ++i) &#123; int a = target - nums[i]; if (mapping.find(a) != mapping.end()) &#123; rev.push_back(mapping.at(a)); rev.push_back(i); return rev; &#125; mapping[nums[i]] = i; &#125; return rev; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://calmnea.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://calmnea.github.io/tags/LeetCode/"},{"name":"算法","slug":"algorithm","permalink":"https://calmnea.github.io/tags/algorithm/"}]},{"title":"Git命令笔记","slug":"Git命令笔记","date":"2018-03-11T11:24:29.000Z","updated":"2018-03-11T17:02:38.911Z","comments":true,"path":"posts/3796511448.html","link":"","permalink":"https://calmnea.github.io/posts/3796511448.html","excerpt":"","text":"日常使用Git时经常记不住相关操作，故将常用的命令记录以便翻查 基本操作 git init 初始化仓库 git clone [url] 克隆远程仓库到本地 git add [file] 添加指定文件到缓存区 git add . 添加所有文件到缓存区 git status 查看仓库当前状态 git diff 对比缓存器与工作区的差异 git pull [remote] [branch] 拉取远程仓库, 并与本地分支合并 git push [remote] [branch] 推送本地指定分支到远程仓库 git push [remote] --force 强制推送当前分支到远程仓库 git push [remote] --all 推送所有分支到远程仓库 git commit -m [message] 将缓存区内容提交到仓库 git reset HEAD 还原工作区与缓存区到上一次提交状态 git reset [file] 还原缓存区中指定文件, 工作区不变 git rm 删除仓库中指定文件 git mv 移动/重命名仓库中的文件 分支 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地和远程分支 git branch [branch-name] 新建分支 git checkout -b [branch-name] 新建并切换分支 git checkout [branch-name] 切换分支 git merge [branch-name] 合并指定分支到当前分支 git branch -d [branch-name] 删除分支 日志 git log 显示当前分支的提交历史 git log --stat 显示每次提交的变更 git log -S [keyword] 根据关键词搜索提交历史 远程仓库 git remote add [name] [url] 新建远程仓库 git remote -v 显示所有远程仓库信息 git remote show [name] 显示指定远程仓库信息 还原 git checkout [file] 还原缓存区指定文件到工作区 git checkout [commit] [file] 还原指定commit的指定文件到缓存区和工作区 git checkout . 还原缓存区所有文件到工作区 git reset --hard 还原缓存区和工作区与上一次commit一致 git reset [commit] 当前分支HEAD变为指定commit, 同时重置缓存区, 但工作区不变 git reset --hard [commit] 当前分支HEAD变为指定commit, 同时重置缓存区和工作区 get reset --keep [commit] 重置当前分支HEAD为指定commit, 但缓存区和工作区都保持不变 常用组合命令 新建远程仓库连接origin，并首次推送 12git remote add origin git@github:xxx/xxx.gitgit push -u origin -all 强制pull远程仓库覆盖本地文件 123git fetch --allgit reset --hard origin/mastergit pull","categories":[{"name":"Git","slug":"Git","permalink":"https://calmnea.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://calmnea.github.io/tags/Git/"},{"name":"笔记","slug":"note","permalink":"https://calmnea.github.io/tags/note/"}]}]}